import sqlite3, json, serial, time, re
import lib.cexprtk as cexprtk
from datetime import datetime
from db_man import DatabaseManager
from os import path
from point import Point
from prog_xbee import ProgrammableXBee

# String constants
CONFIG_PATH = 'coordinator.json'
POINT_CONN_MSG = 'Waiting to join...'
CONN_CONFIRM_MSG = 'Join confirmed'

# Load up the config file
with open(CONFIG_PATH) as config_file:
    env = json.load(config_file)

# Create the database manager
db_man = DatabaseManager(env['local-db-path'])

# Set up the lists of points waiting to connect and already connected with their last readings
points_waiting = []
points_joined = db_man.get_all_points()
last_reading = {}

# Declare the XBee so the functions have access to it
xbee = None


def send_to_server(data):
    """
    Sends data to the main data/web server
    
    data: string of data to send
    """
    # TODO
    pass
    
    
def perform_rule_action(long_address, action):
    """
    Performs the action specified by the provided rule
    
    rule: the rule specifying which action to perform on which device
    """
    
    # TODO
    pass
    

def enforce_rules(long_address):
    """
    Enforces rules set by the user
    
    long_address: the address of the point to check rules for
    """
    
    # TODO UNTESTED
    rules = db_man.get_rules_for_sensor(Point(long_address=long_address))
    for rule in rules:
        failed = False
        subbed_expression = rule.expression
        for match in re.finditer('{([A-Fa-f0-9]+)}', rule.expression):
            # Replace all occurrences of point addresses (enclosed in braces) in the expression with their most recent value
            if match.group(0) not in last_reading:
                # At least one of the addresses specified in the expression doesn't have a last reading, so the expression can't be evaluated
                failed = True
                break
            subbed_expression = re.sub('{([A-Fa-f0-9]+)}', last_reading[match.group(0)], subbed_expression, count=1)
        if failed:
            continue
        
        # Need to explicitly assert the expression returns true here, otherwise non-zero, non-None return values would also pass
        if cexprtk.evaluate_expression(subbed_expression) == True:
            perform_rule_action(rule.long_address, rule.action)


def handle_rx_packet(packet):
    """
    Handles received packets
    
    packet: dictionary representation of a packet generated by the ZigBee class
    """
    
    # Convert the address to a human-readable string
    long_address = packet['source_addr_long'].encode('hex')
    
    # Check if the packet is an initial connection packet from a point
    if POINT_CONN_MSG in packet['rf_data']:
        # Check to see if the point was already connected
        for point in points_joined:
            if point.long_address == long_address:
                xbee.tx(dest_addr_long=long_address.decode('hex'), data=CONN_CONFIRM_MSG)
                return
        
        # DEBUG Temporary section for auto-adding points until the web server is running and we can add from there
        point = Point(long_address=long_address)
        points_joined.append(point)
        db_man.add_point(point)
        xbee.tx(dest_addr_long=long_address.decode('hex'), data=CONN_CONFIRM_MSG)
        
        # Add the point to the list of waiting points the user can add through the web application
        #points_waiting.append(packet['source_addr_long'])
        return
    
    # Point is sending data intended for the server, so cache the value, pass it on and check if there are any rules set on the sensor value
    last_reading[long_address] = re.search('[^:]*:(\d+)\s*.*', packet['rf_data']).group(0)
    send_to_server(packet['rf_data'])
    enforce_rules(long_address)
    

def xbee_callback(packet):
    """
    Callback function that is executed for each received packet
    
    packet: dictionary representation of a packet generated by the ZigBee class
    """
    
    # DEBUG
    print(str(datetime.now()) + str(packet))
    
    # Check the type of packet and dispatch it to the appropriate handler
    if packet['id'] == 'rx':
        handle_rx_packet(packet)


# Entry point

xbee = ProgrammableXBee(env)

while True:
    try:
        # This should be threaded, but a solution for threading with SQLite needs to be implemented first
        xbee_callback(xbee.wait_read_frame())
    except KeyboardInterrupt:
        break
        
xbee.halt()
